simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=3))
# Finally, we make the number of cloisters dependent on the patriarchy index
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI,sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
plot(PI ~ People, data=simulateddataset)
plot(Cloisters~PI,data=simulateddataset)
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
# Now, we can also run the other multivariate analyses. Next is lm(Cloisters)~PI+people
# Here, we do expect a relationship between cloisters and PI but after taking into account variation in the PI, we don't expect a relationship with people, so PI p<0.05, people p>0.05
summary(lm(Cloisters~PI+People,data=simulateddataset))
# Finally, we have people as the outcome. Here, we expect a relationships with the PI because that's how we set it up, but because the relationship to cloisters is mediated by the PI no longer a relationship between people and cloisters, so cloisters p>0.05, PI p<0.05
summary(lm(People~Cloisters+PI,data=simulateddataset))
# Finally, we have people as the outcome. Here, we expect a relationships with the PI because that's how we set it up, but because the relationship to cloisters is mediated by the PI no longer a relationship between people and cloisters, so cloisters p>0.05, PI p<0.05- though again the estimation and p-value for PI might be smaller because of the interference
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We expand our dataframe
simulateddataset<-matrix(nrow=20,ncol=4)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People","Urbanisation")
simulateddataset$Urbanisation<-round(runif(20,min=0,max=1)*20)
simulateddataset$PI<-round(rnorm(20,mean=(20/simulateddataset$Urbanisation),sd=3))
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset$People<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset
simulateddataset$Urbanisation<-round(runif(20,min=1,max=2)*10)
simulateddataset
simulateddataset$Urbanisation<-round(runif(20,min=0.05,max=1)*20)
simulateddataset
hist(round(runif(10000,min=0.05,max=1)*20))
# We expand our dataframe
simulateddataset<-matrix(nrow=20,ncol=4)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People","Urbanisation")
simulateddataset$Urbanisation<-round(runif(20,min=0.05,max=1)*20)
simulateddataset$PI<-round(rnorm(20,mean=(20/simulateddataset$Urbanisation),sd=3))
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset$People<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset
simulateddataset$PI<-round(rnorm(20,mean=(24/simulateddataset$Urbanisation),sd=3))
simulateddataset
simulateddataset$PI<-round(rnorm(20,mean=(18/simulateddataset$Urbanisation),sd=3))
simulateddataset
# We expand our dataframe
simulateddataset<-matrix(nrow=20,ncol=4)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People","Urbanisation")
simulateddataset$Urbanisation<-round(runif(20,min=0.05,max=1)*20)
simulateddataset$PI<-round(rnorm(20,mean=(20/simulateddataset$Urbanisation),sd=3))
simulateddataset[simulateddataset$PI<0,]$PI<-0
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
simulateddataset$People<-round(rnorm(20,mean=simulateddataset$Urbanisation,sd=3))
simulateddataset[simulateddataset$People<0,]$People<-0
simulateddataset
plot(PI ~ People, data=simulateddataset)
plot(Cloisters~PI,data=simulateddataset)
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
plot(PI ~ People, data=simulateddataset)
plot(Cloisters~PI,data=simulateddataset)
plot(Cloisters~People,data=simulateddataset)
# Now, we run our first multivariate analysis (lm(PI) ~ cloisters + people). We don't really know what to expect here.
summary(lm(PI~Cloisters+People,data=simulateddataset))
# Now, we run our multivariate analyses. For all three multivariabe analyses, we don't really know what to expect here - it all depends on how tight the relationships are. Sometimes we would expect that only one of the associations has a p-value smaller than 0.05, and sometimes both. As above, maybe run this repeatedly to see how things change. Maybe also change the sd=3 in one or all of the code that generates the three variables based on the urbanism score higher (e.g. sd=5) or lower (e.g. sd=1) to see whether increasing or reducing noise changes the outcome.
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# Now, we run our multivariate analyses. For all three multivariabe analyses, we don't really know what to expect here - it all depends on how tight the relationships are. Sometimes we would expect that only one of the associations has a p-value smaller than 0.05, and sometimes both. As above, maybe run this repeatedly to see how things change. Maybe also change the sd=3 in one or all of the code that generates the three variables based on the urbanism score higher (e.g. sd=5) or lower (e.g. sd=1) to see whether increasing or reducing noise changes the outcome.
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=3))
# Finally, we make the number of cloisters dependent on the patriarchy index
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI,sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
plot(PI ~ People, data=simulateddataset)
plot(Cloisters~PI,data=simulateddataset)
plot(Cloisters~People,data=simulateddataset)
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=3))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
simulateddataset
plot(Cloisters~People,data=simulateddataset)
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=3))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=5))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=5))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=5))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=5))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=5))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=5))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We use our normal setup again
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the patriarchy index dependent on this, again with a negative relationship
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=5))
# Finally, we make the number of cloisters dependent on the patriarchy index and the number of people
simulateddataset$Cloisters<-round(rnorm(20,mean=simulateddataset$PI+(simulateddataset$People/100),sd=5))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
# In this scenario, we won't see a relationship between people and cloisters even though we simulated one, because the positive direct and the negative indirect effect generally cancel each other out
plot(Cloisters~People,data=simulateddataset)
summary(lm(Cloisters~People,data=simulateddataset))
summary(lm(PI~Cloisters+People,data=simulateddataset))
summary(lm(Cloisters~PI+People,data=simulateddataset))
summary(lm(People~Cloisters+PI,data=simulateddataset))
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the number of monasteries dependent on the number of people. We set the noise (the standard deviation) a bit smaller (3 instead of 5) because we want a tighter association to get the potential indirect association between cloisters and PI (see below)
simulateddataset$Cloisters<-round(rnorm(20,mean=(simulateddataset$People/100),sd=3))
simulateddataset<-matrix(nrow=20,ncol=3)
simulateddataset<-as.data.frame(simulateddataset)
colnames(simulateddataset)<-c("PI","Cloisters","People")
# We first generate the number of people at each location
simulateddataset$People<-round(rnorm(20,mean=1000,sd=250))
# Next, we set the number of monasteries dependent on the number of people. We set the noise (the standard deviation) a bit smaller (3 instead of 5) because we want a tighter association to get the potential indirect association between cloisters and PI (see below)
simulateddataset$Cloisters<-round(rnorm(20,mean=(simulateddataset$People/100),sd=3))
simulateddataset[simulateddataset$Cloisters<0,]$Cloisters<-0
plot(Cloisters~People,data=simulateddataset)
# And we also set the patriarchy index dependent on the number of people, with a negative relationship
# To get the negative relationship, here we divide 10000 by the number of people in the area. That again wil give us values of around 10, but this time larger number of people will lead to smaller values (e.g. 10000/1000 = 10; 10000/2000 = 5). We set the noise (the standard deviation) a bit smaller (3 instead of 5) because we want a tighter association to get the potential indirect association between cloisters and PI (see below)
simulateddataset$PI<-round(rnorm(20,mean=(10000/simulateddataset$People),sd=3))
plot(PI~People,data=simulateddataset)
summary(lm(Cloisters~PI,data=simulateddataset))
# Now, we run our first multivariate analysis (lm(PI) ~ cloisters + people). Here, we expect that number of people predicts the PI - but once we know the number of people, there is no additional information in also knowing the number of cloisters because the number of cloisters itself is also set by the number of people. So we expect: cloisters p>0.05, people p<0.05. Again, because there is noise, we might not always find that relationship of people p<0.05 because the model doesn't know which factor to prioritize and says that well some of the variation in the PI is also associated with the variation in cloisters. As mentioned before, repeat the simulation for this prediction a few times to see the different outcomes.
summary(lm(PI~Cloisters+People,data=simulateddataset))
# Now, we can also run the other multivariate analyses. Next is lm(Cloisters)~PI+people
# Here, we do expect a relationship between cloisters and people but not with the PI, so PI p>0.05, people p<0.05
summary(lm(Cloisters~PI+People,data=simulateddataset))
# Finally, we have people as the outcome. Here, we expect a relationships with both because that's how we set it up, so cloisters p<0.05, PI p<0.05
summary(lm(People~Cloisters+PI,data=simulateddataset))
library(metafor)
library(ape)
library(geiger)
library(dplyr)
library(readr)
library(orchaRd)
library(patchwork)
library(ggplot2)
library(rethinking)
library(metafor)
library(ape)
library(geiger)
library(dplyr)
library(readr)
library(orchaRd)
library(patchwork)
library(ggplot2)
library(rethinking)
inputdata<-read_csv(url("https://raw.githubusercontent.com/dieterlukas/FemaleDominanceReproduction_MetaAnalysis/trunk/Inputfiles/InputData_MetaAnalysis_FemaleDominanceReproduction.csv"))
inputdata<-data.frame(inputdata)
dat<-inputdata
setwd("~/ownCloud/Documents/GitHub/FemaleDominanceReproduction_MetaAnalysis/Manuscriptfiles")
options(width=60)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy=TRUE)
# Load the consensus tree for the 86 species in the actual dataset
mammaltree<-read.nexus(url("https://raw.githubusercontent.com/dieterlukas/FemaleDominanceReproduction_MetaAnalysis/trunk/Inputfiles/CombinedTree_MetaAnalysis_RankSuccess.nex"))
unique(dat$Latin)
sort(unique(dat$Latin))
# Some of the Latin species names in the input file do not match the species name that were used for the phylogenetic tree. We can adapt these here
#Instead of Canis familiaris we use Canis lupus
dat[dat$Latin=="Canis_familiaris",]$Latin<-"Canis_lupus"
dat[dat$Latin=="Fukomys_mechowii",]$Latin<-"Fukomys_mechowi"
dat[dat$Latin=="Bos_bison",]$Latin<-"Bison_bison"
phylo_branch <- compute.brlen(mammaltree, method = "Grafen", power = 1)
phylo_cor <- vcv(phylo_branch, cor = T)
Dmat<-cophenetic(mammaltree)
spp_obs<-unique(dat$Latin)
spp_obs<-matrix(nrow=length(spp_obs))
rownames(spp_obs)<-unique(dat$Latin)
dat$SpeciesIncluded<-dat$Latin
# The dataset was cleaned during the preparation, which led to the exclusion of an entry for one of the species. For some analyses, the species identities need to be numbered consecutively, so we are changing the identities of species 88 to the missing identity 34 (to have identities 1-87)
dat[dat$SpeciesRef==88,]$SpeciesRef<-34
dat[dat$Latin=="Macaca_assamensis",]$LittersPerYear<-0.6
dat[dat$Latin=="Apodemus_sylvaticus",]$CooperativeBreeding<-1
dat[dat$Latin=="Canis_rufus",]$CooperativeBreeding<-1
dat[dat$Latin=="Ceratotherium_simum",]$AssociatedBreeding<-1
dat[dat$Latin=="Marmota_marmota",]$CooperativeBreeding<-1
dat[dat$Latin=="Mesocricetus_auratus",]$PluralBreeding<-1
dat[dat$Latin=="Microtus_ochrogaster",]$CooperativeBreeding<-1
dat[dat$Latin=="Microtus_pinetorum",]$CooperativeBreeding<-1
dat[dat$Latin=="Odocoileus_virginianus",]$PluralBreeding<-1
dat[dat$Latin=="Oryctolagus_cuniculus",]$PluralBreeding<-1
dat[dat$Latin=="Ozotoceros_bezoarticus",]$AssociatedBreeding<-1
dat[dat$Latin=="Vulpes_vulpes",]$CooperativeBreeding<-1
dat$BreedingSystem <-dat$CooperativeBreeding*1+dat$PluralBreeding*2+dat$AssociatedBreeding*3
write.csv(dat,file="InputData_MetaAnalysis_FemaleDominanceReproduction.csv")
inputdata<-read_csv(url("https://raw.githubusercontent.com/dieterlukas/FemaleDominanceReproduction_MetaAnalysis/trunk/Inputfiles/InputData_MetaAnalysis_FemaleDominanceReproduction.csv"))
inputdata<-data.frame(inputdata)
dat<-inputdata
head(dat)
colnames(dat)
inputdata<-read_csv(url("https://raw.githubusercontent.com/dieterlukas/FemaleDominanceReproduction_MetaAnalysis/trunk/Inputfiles/InputData_MetaAnalysis_FemaleDominanceReproduction.csv"))
inputdata<-data.frame(inputdata)
dat<-inputdata
colnames(dat)
head(dat)
dat[1,5]
dat<-dat[,c(3:32,37,36,33:35)]
head(dat)
colnames(dat)
# Load the consensus tree for the 86 species in the actual dataset
mammaltree<-read.nexus(url("https://raw.githubusercontent.com/dieterlukas/FemaleDominanceReproduction_MetaAnalysis/trunk/Inputfiles/CombinedTree_MetaAnalysis_RankSuccess.nex"))
sort(unique(dat$SpeciesRef))
dat[dat$Latin=="Macaca_assamensis",]$LittersPerYear
dat[dat$Latin=="Apodemus_sylvaticus",]$CooperativeBreeding
table(dat$Populationtype)
table(dat$MeasureType_Category)
littersizedat<-dat[is.na(dat$LitterSize)==F,]
nrow(littersizedat)
littersizedat<-dat[is.na(dat$LittersPerYear)==F,]
nrow(littersizedat)
littersizedat<-dat[is.na(dat$DietCategory)==F,]
nrow(littersizedat)
table(dat$DietCategory)
harshnessdat<-dat[is.na(dat$EnvironmentalHarshness)==F,]
nrow(harshnessdat)
densitydat<-dat[is.na(dat$PopulationDensity)==F,]
nrow(densitydat)
table(dat$BreedingSystem)
sum(dat$CooperativeBreeding)
sum(dat$PluralBreeding)
table(dat$DominanceSystem)
table(dat$Philopary)
table(dat$Philopatry)
groupsizedata<-dat[is.na(dat$GroupSize)==F,]
nrow(groupsizedata)
relatednessdat<-dat[is.na(dat$AverageRelatedness)==F,]
nrow(relatednessdat)
metafor_phylogenetic_relatedness <- rma.mv(Fishers_Z_r, Variance,
mod =~AverageRelatedness,
random=list(~ 1 | SpeciesIncluded, # linking the species to the phylogeny
~ 1 | Latin, # observations from the same species might be similar to each other, even if those from closely related species are not
~ 1 | StudyRef),  # accounting for observations from the same publication
R = list(SpeciesIncluded = phylo_cor), # reflecting the phylogenetic relatedness
method="REML",
test="t",
data=dat)
metafor_phylogenetic_relatedness
coalitiondat
coalitiondat<-dat[is.na(dat$CoalitionFormation)==F,]
table(coalitiondat$CoalitionFormation)
metafor_phylogenetic_coalition <- rma.mv(Fishers_Z_r, Variance,
mod =~CoalitionFormation,
random=list(~ 1 | SpeciesIncluded, # linking the species to the phylogeny
~ 1 | Latin, # observations from the same species might be similar to each other, even if those from closely related species are not
~ 1 | StudyRef),  # accounting for observations from the same publication
R = list(SpeciesIncluded = phylo_cor), # reflecting the phylogenetic relatedness
method="REML",
test="t",
data=dat)
metafor_phylogenetic_coalition
sexratiodat<-dat[is.na(dat$sexratio_socialgroup)==F,]
nrow(sexratiodat)
metafor_phylogenetic_sexratio <- rma.mv(Fishers_Z_r, Variance,
mod =~sexratio_socialgroup,
random=list(~ 1 | SpeciesIncluded, # linking the species to the phylogeny
~ 1 | Latin, # observations from the same species might be similar to each other, even if those from closely related species are not
~ 1 | StudyRef),  # accounting for observations from the same publication
R = list(SpeciesIncluded = phylo_cor), # reflecting the phylogenetic relatedness
method="REML",
test="t",
data=dat)
metafor_phylogenetic_sexratio
infanticidedat<-dat[is.na(dat$maleinfanticide)==F,]
nrow(infanticidedat)
metafor_phylogenetic_infanticide <- rma.mv(Fishers_Z_r, Variance,
mod =~maleinfanticide,
random=list(~ 1 | SpeciesIncluded, # linking the species to the phylogeny
~ 1 | Latin, # observations from the same species might be similar to each other, even if those from closely related species are not
~ 1 | StudyRef),  # accounting for observations from the same publication
R = list(SpeciesIncluded = phylo_cor), # reflecting the phylogenetic relatedness
method="REML",
test="t",
data=dat)
metafor_phylogenetic_infanticide
infanticidedat<-dat[is.na(dat$maleinfanticide)==F,]
dat_list_infanticide <- list(
N_spp = nrow(infanticidedat),
Z_obs = infanticidedat$Fishers_Z_r,
Z_sd = infanticidedat$Variance,
M = as.integer(as.factor(infanticidedat$maleinfanticide))
)
dat_list_phylogenetic_infanticide$Dmat<-Dmat[infanticidedat$Latin,infanticidedat$Latin ]/max(Dmat)
rethinking_phylogenetic_gaussian_infanticide <- ulam(
alist(
Z_obs ~dnorm ( Z_true , Z_sd),
vector[N_spp]:Z_true ~ multi_normal( mu , SIGMA ),
mu <- a+b[M],
matrix[N_spp,N_spp]: SIGMA <- cov_GPL2( Dmat, etasq, rhosq, 0.01),
a~normal(0,1),
b[M]~normal(0,0.5),
etasq~exponential(1),
rhosq~exponential(1)
),data=dat_list_phylogenetic_infanticide)
precis(rethinking_phylogenetic_gaussian_infanticide)
dat_list_phylogenetic_infanticide <- list(
N_spp = nrow(infanticidedat),
Z_obs = infanticidedat$Fishers_Z_r,
Z_sd = infanticidedat$Variance,
M = as.integer(as.factor(infanticidedat$maleinfanticide))
)
dat_list_phylogenetic_infanticide$Dmat<-Dmat[infanticidedat$Latin,infanticidedat$Latin ]/max(Dmat)
rethinking_phylogenetic_gaussian_infanticide <- ulam(
alist(
Z_obs ~dnorm ( Z_true , Z_sd),
vector[N_spp]:Z_true ~ multi_normal( mu , SIGMA ),
mu <- a+b[M],
matrix[N_spp,N_spp]: SIGMA <- cov_GPL2( Dmat, etasq, rhosq, 0.01),
a~normal(0,1),
b[M]~normal(0,0.5),
etasq~exponential(1),
rhosq~exponential(1)
),data=dat_list_phylogenetic_infanticide)
precis(rethinking_phylogenetic_gaussian_infanticide)
precis(rethinking_phylogenetic_gaussian_infanticide,depth=2)
precis(rethinking_phylogenetic_gaussian_infanticide,depth=2)[330:338,]
posterior<-extract.samples(dat_list_phylogenetic_infanticide)
difference_phylo_infanticide<-posterior$b[,2]-posterior$b[,1]
posterior<-extract.samples(rethinking_phylogenetic_gaussian_infanticide)
difference_phylo_infanticide<-posterior$b[,2]-posterior$b[,1]
difference_phylo_infanticide
precis(difference_phylo_infanticide)
sexualdimorphismdat<-dat[is.na(dat$SexualDimorphism_Weight)==F,]
nrow(sexualdimorphismdat)
cooperative<-dat[dat$CooperativeBreeding==1,]
meta_MeasureType_Category_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ MeasureType_Category, data=cooperative, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_MeasureType_Category_cooperativebreeding
0.6044-0.1372-.3326
0.6044-0.1372-0.3326
0.6044+0.1372+0.0581
0.6044-0.1372
0.4672-0.3326
0.4672+0.0581
0.6044-0.2003
0.4041-0.5871
0.4041+0.1865
0.6044-0.5871
0.4041+.1865
notcooperative<-dat[dat$CooperativeBreeding==0,]
meta_MeasureType_Category_notcooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ MeasureType_Category, data=notcooperative, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_MeasureType_Category_cooperativebreeding
meta_MeasureType_Category_notcooperativebreeding
0.3128-0.0686-0.0505
0.3128-0.0686+0.0505
0.3128-0.0444
0.3128+0.0444
0.3128-0.0279 - 0.0506
0.3128-0.0279 + 0.0506
0.3128-0.1400  -0.0433
0.3128-0.1400  +0.0433
0.3128-0.1560-  0.0442
0.3128-0.1560+  0.0442
0.3128-0.1209  0.0480
0.3128-0.1209-  0.0480
0.3128-0.1209+  0.0480
dat_list <- list(
N_spp = nrow(notcooperative),
Z_obs = notcooperative$Fishers_Z_r,
Z_sd = notcooperative$Variance,
M = as.integer(as.factor(notcooperative$MeasureType_Category))
)
rethinking_notcooperation_measures <- ulam(
alist(
Z_obs ~dnorm ( Z_true , Z_sd),
vector[N_spp]:Z_true ~ dnorm( mu , sigma_sq ),
mu <-  m[M],
m[M] ~ dnorm(0,1),
sigma_sq~dexp(1)
),data=dat_list)
precis(rethinking_notcooperation_measures,depth=2)[393:399,]
table(dat_list$M)
table(notcooperative$MeasureType_Category)
meta_littersperyear_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ CooperativeBreeding+LittersPerYear, data=dat, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_littersperyear_cooperativebreeding
meta_littersperyear_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ CooperativeBreeding*LittersPerYear, data=dat, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_littersperyear_cooperativebreeding
meta_littersperyear_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ CooperativeBreeding+LittersPerYear, data=dat, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_littersperyear_cooperativebreeding
meta_littersperyear_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ CooperativeBreeding*LittersPerYear, data=dat, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_littersperyear_cooperativebreeding
meta_littersperyear_cooperativebreeding <- rma.mv(yi=Fishers_Z_r, V=Variance, mods=~ CooperativeBreeding*LittersPerYear, data=dat, method="REML", random=list(~1|StudyRef,~1|SpeciesRef))
meta_littersperyear_cooperativebreeding
metafor_phylogenetic_littersperyear_cooperativebreeding
metafor_phylogenetic_littersperyear_cooperativebreeding <- rma.mv(Fishers_Z_r, Variance,
mod =~CooperativeBreeding*LittersPerYear,
random=list(~ 1 | SpeciesIncluded, # linking the species to the phylogeny
~ 1 | Latin, # observations from the same species might be similar to each other, even if those from closely related species are not
~ 1 | StudyRef),  # accounting for observations from the same publication
R = list(SpeciesIncluded = phylo_cor), # reflecting the phylogenetic relatedness
method="REML",
test="t",
data=dat)
metafor_phylogenetic_littersperyear_cooperativebreeding
dat_list <- list(
N_spp = nrow(dat),
Z_obs = dat$Fishers_Z_r,
Z_sd = dat$Variance,
B = dat$BreedingSystem,
L = standardize(dat$LittersPerYear)
)
dat_list$Dmat<-Dmat[ dat$Latin,dat$Latin ]/max(Dmat)
rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding <- ulam(
alist(
Z_obs ~dnorm ( Z_true , Z_sd),
vector[N_spp]:Z_true ~ multi_normal( mu , SIGMA ),
mu <- a + c[C]+g*G,
g~normal(0,1),
matrix[N_spp,N_spp]: SIGMA <- cov_GPL2( Dmat, etasq, rhosq, 0.01),
a~normal(0,1),
c[C]~normal(0,0.5),
etasq~exponential(1),
rhosq~exponential(1)
),data=dat_list,chains=4)
precis(rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding)
rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding <- ulam(
alist(
Z_obs ~dnorm ( Z_true , Z_sd),
vector[N_spp]:Z_true ~ multi_normal( mu , SIGMA ),
mu <- a + b[B]*L,
g~normal(0,1),
matrix[N_spp,N_spp]: SIGMA <- cov_GPL2( Dmat, etasq, rhosq, 0.01),
a~normal(0,1),
b[B]~normal(0,0.5),
etasq~exponential(1),
rhosq~exponential(1)
),data=dat_list,chains=4)
precis(rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding)
precis(rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding,depth=2)
precis(rethinking_phylogenetic_gaussian_littersperyear_cooperativebreeding,depth=2)[445:450,]
table(dat$BreedingSystem)
sum(dat$CooperativeBreeding)
